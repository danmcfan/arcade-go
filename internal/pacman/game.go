package pacman

import (
	"time"

	"github.com/nsf/termbox-go"
)

const (
	Width  = 28
	Height = 31
)

type State byte

const (
	GameOver State = 0
	Playing  State = 1
)

type Maze [Height][Width]byte

type Pixel byte

const (
	Open    Pixel = 0
	Dot     Pixel = 1
	PowerUp Pixel = 2

	Pacman Pixel = 10

	RedGhost   Pixel = 20
	PinkGhost  Pixel = 21
	GreenGhost Pixel = 22
	GrayGhost  Pixel = 23

	Wall Pixel = 100
	Gate Pixel = 101
)

type Direction rune

const (
	None  Direction = ' '
	Up    Direction = 'w'
	Down  Direction = 's'
	Left  Direction = 'a'
	Right Direction = 'd'
)

type Game struct {
	state State
	maze  Maze

	x, y      int
	direction Direction
}

func gameLoop(game *Game, gameTick *time.Ticker, keyboardEvents <-chan termbox.Event, exit chan<- bool) {
	for {
		select {
		case ev := <-keyboardEvents:
			if ev.Type == termbox.EventKey {
				switch ev.Ch {
				case 'w', 's', 'a', 'd', 'r':
					handleInput(game, ev.Ch)
				case 'q':
					exit <- true
				}
			}
		case <-gameTick.C:
			game.update()
			draw(*game)
		}
	}
}

func handleInput(g *Game, ch rune) {
	if ch == 'r' && g.state == GameOver {
		*g = newGame()
		return
	}
	g.direction = Direction(ch)
}

func newGame() Game {
	initialMaze := Maze{
		{100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100},
		{100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100},
		{100, 1, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 1, 100},
		{100, 2, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 2, 100},
		{100, 1, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 1, 100},
		{100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100},
		{100, 1, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 1, 100},
		{100, 1, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 1, 100},
		{100, 1, 1, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 1, 1, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 0, 100, 100, 0, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 0, 100, 100, 0, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 100, 100, 100, 101, 101, 100, 100, 100, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 100, 0, 0, 0, 0, 0, 0, 100, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 100, 0, 21, 0, 22, 0, 23, 100, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 100, 0, 0, 0, 0, 0, 0, 100, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 100, 100, 100, 100, 100, 100, 100, 100, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 100, 100, 100, 100, 100, 100, 100, 100, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 100, 100, 100, 100, 100, 1, 100, 100, 0, 100, 100, 100, 100, 100, 100, 100, 100, 0, 100, 100, 1, 100, 100, 100, 100, 100, 100},
		{100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100},
		{100, 1, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 1, 100},
		{100, 1, 100, 100, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 1, 100, 100, 100, 100, 1, 100},
		{100, 2, 1, 1, 100, 100, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 100, 100, 1, 1, 2, 100},
		{100, 100, 100, 1, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 1, 100, 100, 100},
		{100, 100, 100, 1, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 1, 100, 100, 100},
		{100, 1, 1, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 100, 100, 1, 1, 1, 1, 1, 1, 100},
		{100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100},
		{100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100, 100, 1, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1, 100},
		{100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100},
		{100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100},
	}

	return Game{
		state:     Playing,
		maze:      initialMaze,
		x:         14,
		y:         23,
		direction: None,
	}
}

func (g *Game) update() {
	nextX, nextY := g.x, g.y

	switch g.direction {
	case Up:
		nextY--
	case Down:
		nextY++
	case Left:
		nextX--
	case Right:
		nextX++
	}

	nextPixel := Pixel(g.maze[nextY][nextX])

	if nextPixel == Wall || nextPixel == Gate {
		return
	}

	if nextPixel == RedGhost || nextPixel == PinkGhost || nextPixel == GreenGhost || nextPixel == GrayGhost {
		g.state = GameOver
	}

	g.maze[g.y][g.x] = byte(Open)
	g.maze[nextY][nextX] = byte(Pacman)

	g.x = nextX
	g.y = nextY
}
